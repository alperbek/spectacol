import qbs 1.0
import qbs.FileInfo
import qbs.Probes
import qbs.TextFile

Module {
    id: configure
    name: 'configure'
    Depends { name: 'cpp' }

    Probes.BinaryProbe {
        id: perl
        names: ["perl"]
    }

    property path PERL_PATH: perl.filePath

//    Probes.PkgConfigProbe {
//        id: audiofile
//        name: "audiofile"
//    }

//    Probes.IncludeProbe {
//        id: bzlib
//        names: "bzlib.h"
//    }

//    Probes.IncludeProbe {
//        id: gcrypt
//        names: "gcrypt.h"
//    }

//    Probes.IncludeProbe {
//        id: stdint
//        names: "stdint.h"
//    }

//    Probes.IncludeProbe {
//        id: strings
//        names: "strings.h"
//    }

//    Probes.IncludeProbe {
//        id: unistd
//        names: "unistd.h"
//    }

//    Probes.IncludeProbe {
//        id: zlib
//        names: "zlib.h"
//    }

    validate:  {
        if (!perl.found)
            throw 'Perl not found';
    }

//    cpp.linkerFlags: {
//        var flags = [];
//        if (gcrypt.found)
//            flags.push('-lgcrypt');

//        if (audiofile.found)
//            flags.push(audiofile.libs);
//        return flags;
//    }

//    cpp.cxxFlags: {
//        var flags = [];
//        if (audiofile.found)
//            flags.push(audiofile.cflags);
//        return flags;
//    }

    property string CONFIG_H: {
        var content='#define VERSION "2.0.0"\n#define FUSE_COPYRIGHT "(c) 1999-2013 Philip Kendall and others"\n';
//        if (audiofile.found)
//            content += "#define HAVE_LIB_AUDIOFILE 1\n";

//        if (bzlib.found)
//            content += "#define HAVE_LIBBZ2 1\n";

//        if (gcrypt.found)
//            content += "#define HAVE_GCRYPT_H 1\n";

//        if (strings.found)
//            content += "#define HAVE_STRINGS_H 1\n";

//        if (unistd.found)
//            content += "#define HAVE_UNISTD_H 1\n";

//        if (zlib.found)
//            content += "#define HAVE_ZLIB_H 1\n";
        return content;
    }

//    property string LIBSPECTRUM_CAPABILITIES: {
//        var content='';
//        if (zlib.found)
//            content += "\
///* we support snapshots etc. requiring zlib (e.g. compressed szx) */\n\
//#define	LIBSPECTRUM_SUPPORTS_ZLIB_COMPRESSION	(1)\n\n\
///* zlib (de)compression routines */\n\n\
//WIN32_DLL libspectrum_error\n\
//libspectrum_zlib_inflate( libspectrum_context_t *context, const libspectrum_byte *gzptr, size_t gzlength,\n\
//              libspectrum_byte **outptr, size_t *outlength );\n\n\
//WIN32_DLL libspectrum_error\n\
//libspectrum_zlib_compress( libspectrum_context_t *context, const libspectrum_byte *data, size_t length,\n\
//               libspectrum_byte **gzptr, size_t *gzlength );\n\n";

//        if (bzlib.found)
//            content += "\
///* we support files compressed with bz2 */\n\
//#define	LIBSPECTRUM_SUPPORTS_BZ2_COMPRESSION	(1)\n\n";

//        if (audiofile.found)
//            content += "\
///* we support wav files */\n\
//#define	LIBSPECTRUM_SUPPORTS_AUDIOFILE	(1)\n\n";
//        return content;
//    }

//    property bool HAVE_STDINT_H: stdint.found
//    property bool HAVE_GCRYPT_H: gcrypt.found

    Transformer {
        Artifact {
            fileTags: 'h'
            filePath: 'config.h'
        }

        prepare: {
            var cmd = new JavaScriptCommand();
            cmd.description = "generating config.h";
            cmd.highlight = "filegen";
            cmd.sourceCode = function() {
                var file = TextFile(output.filePath, TextFile.WriteOnly);
                file.truncate();
                file.write(product.moduleProperty("configure", "CONFIG_H"));
                file.close();
            }
            return cmd;
        }
    }

//    Rule {
//        inputs: ['libspectrum.h.in', 'snap_accessors.txt', 'tape_accessors.txt']

//        Artifact {
//            fileTags: 'hpp'
//            filePath: 'libspectrum.h'
//        }

//        prepare: {
//            var cmd = new JavaScriptCommand();
//            cmd.description = 'generating libspectrum.h';
//            cmd.highlight = 'filegen';
//            cmd.sourceCode = function() {
//                var baseDir = FileInfo.path(input.filePath);
//                var file = new TextFile(baseDir + '/libspectrum.h.in');
//                var content = file.readAll();
//                content = content.replace("LIBSPECTRUM_AUTOGEN_WARNING", "/* NB: This file is autogenerated from libspectrum.h.in. Do not edit\nunless you know what you're doing */");
//                if (product.moduleProperty("configure", "HAVE_GCRYPT_H")) {
//                    content = content.replace("LIBSPECTRUM_INCLUDE_GCRYPT", "#include <gcrypt.h>");
//                    content = content.replace("LIBSPECTRUM_SIGNATURE_PARAMETERS", "  /* The DSA signature parameters 'r' and 's' */\n  gcry_mpi_t r, s;\n");
//                }

//                if (product.moduleProperty("configure", "HAVE_STDINT_H"))
//                    content = content.replace("LIBSPECTRUM_DEFINE_TYPES", function(){/*#include <stdint.h>

//typedef  uint8_t libspectrum_byte;
//typedef   int8_t libspectrum_signed_byte;
//typedef uint16_t libspectrum_word;
//typedef  int16_t libspectrum_signed_word;
//typedef uint32_t libspectrum_dword;
//typedef  int32_t libspectrum_signed_dword;
//typedef uint64_t libspectrum_qword;
//typedef  int64_t libspectrum_signed_qword;
//*/}.toString().slice(15,-4));
//                else
//                    content = content.replace("LIBSPECTRUM_DEFINE_TYPES", function(){/*typedef unsigned char libspectrum_byte;
//typedef   signed char libspectrum_signed_byte;
//typedef unsigned short libspectrum_word;
//typedef   signed short libspectrum_signed_word;
//typedef unsigned int libspectrum_dword;
//typedef   signed int libspectrum_signed_dword;
//typedef unsigned long libspectrum_qword;
//typedef   signed long libspectrum_signed_qword;
//*/}.toString().slice(15,-4));

//                content = content.replace("LIBSPECTRUM_GLIB_REPLACEMENT", function(){/*
//#define LIBSPECTRUM_HAS_GLIB_REPLACEMENT 1

//#ifndef	FALSE
//#define	FALSE	(0)
//#endif

//#ifndef	TRUE
//#define	TRUE	(!FALSE)
//#endif

//typedef char gchar;
//typedef int gint;
//typedef long glong;
//typedef gint gboolean;
//typedef unsigned int guint;
//typedef unsigned long gulong;
//typedef const void * gconstpointer;
//typedef void * gpointer;

//typedef struct _GSList GSList;

//struct _GSList {
//    gpointer data;
//    GSList *next;
//};

//typedef void		(*GFunc)		(gpointer	data,
//                         gpointer	user_data);

//typedef gint		(*GCompareFunc)		(gconstpointer	a,
//                         gconstpointer	b);

//typedef void           (*GDestroyNotify)       (gpointer       data);

//typedef void           (*GFreeFunc)            (gpointer       data);


//WIN32_DLL GSList *g_slist_insert_sorted	(GSList		*list,
//                         gpointer	 data,
//                         GCompareFunc	 func);

//WIN32_DLL GSList *g_slist_insert		(GSList		*list,
//                         gpointer	 data,
//                         gint		 position);

//WIN32_DLL GSList *g_slist_append		(GSList		*list,
//                         gpointer	 data);

//WIN32_DLL GSList *g_slist_prepend		(GSList		*list,
//                         gpointer	 data);

//WIN32_DLL GSList *g_slist_remove		(GSList		*list,
//                         gconstpointer	 data);

//WIN32_DLL GSList *g_slist_last			(GSList		*list);

//WIN32_DLL GSList *g_slist_reverse		(GSList		*list);

//WIN32_DLL GSList *g_slist_delete_link		(GSList		*list,
//                         GSList		*link);

//WIN32_DLL guint	g_slist_length		(GSList *list);

//WIN32_DLL void	g_slist_foreach			(GSList		*list,
//                         GFunc		 func,
//                         gpointer	 user_data);

//WIN32_DLL void	g_slist_free			(GSList		*list);

//WIN32_DLL GSList *g_slist_nth		(GSList		*list,
//                     guint		n);

//WIN32_DLL GSList *g_slist_find_custom	(GSList		*list,
//                     gconstpointer	data,
//                     GCompareFunc	func );

//WIN32_DLL gint	g_slist_position	(GSList		*list,
//                     GSList		*llink);

//typedef struct _GHashTable	GHashTable;

//typedef guint		(*GHashFunc)		(gconstpointer	key);

//typedef void	(*GHFunc)		(gpointer	key,
//                         gpointer	value,
//                         gpointer	user_data);

//typedef gboolean	(*GHRFunc)		(gpointer	key,
//                         gpointer	value,
//                         gpointer	user_data);

//WIN32_DLL gint	g_int_equal (gconstpointer   v,
//                   gconstpointer   v2);
//WIN32_DLL guint	g_int_hash  (gconstpointer   v);

//WIN32_DLL gint	g_str_equal (gconstpointer   v,
//                   gconstpointer   v2);
//WIN32_DLL guint	g_str_hash  (gconstpointer   v);

//WIN32_DLL GHashTable *g_hash_table_new	(GHashFunc	 hash_func,
//                     GCompareFunc	 key_compare_func);

//WIN32_DLL GHashTable *g_hash_table_new_full (GHashFunc       hash_func,
//                                             GCompareFunc    key_equal_func,
//                                             GDestroyNotify  key_destroy_func,
//                                             GDestroyNotify  value_destroy_func);

//WIN32_DLL void	g_hash_table_destroy	(GHashTable	*hash_table);

//WIN32_DLL void	g_hash_table_insert	(GHashTable	*hash_table,
//                     gpointer	 key,
//                     gpointer	 value);

//WIN32_DLL gpointer g_hash_table_lookup	(GHashTable	*hash_table,
//                     gconstpointer	 key);

//WIN32_DLL void	g_hash_table_foreach (GHashTable	*hash_table,
//                         GHFunc    func,
//                         gpointer  user_data);

//WIN32_DLL guint	g_hash_table_foreach_remove	(GHashTable	*hash_table,
//                         GHRFunc	 func,
//                         gpointer	 user_data);

//WIN32_DLL guint	g_hash_table_size (GHashTable	*hash_table);

//typedef struct _GArray GArray;

//struct _GArray {
//  // Public
//  gchar *data;
//  size_t len;

//  // Private
//  guint element_size;
//  size_t allocated;
//};

//WIN32_DLL GArray* g_array_new( gboolean zero_terminated, gboolean clear,
//              guint element_size );
//#define g_array_append_val(a,v) g_array_append_vals( a, &(v), 1 );
//WIN32_DLL GArray* g_array_append_vals( GArray *array, gconstpointer data, guint len );
//#define g_array_index(a,t,i) (*(((t*)a->data)+i))
//WIN32_DLL GArray* g_array_set_size( GArray *array, guint length );
//WIN32_DLL gchar* g_array_free( GArray *array, gboolean free_segment );

//#define GINT_TO_POINTER(i)      ((gpointer)  (glong)(i))
//#define GPOINTER_TO_INT(p)      ((gint)   (glong)(p))
//#define GPOINTER_TO_UINT(p)     ((guint)  (gulong)(p))
//*/}.toString().slice(15,-4));
//                //                content = content.replace("LIBSPECTRUM_GLIB_REPLACEMENT", '#define LIBSPECTRUM_HAS_GLIB_REPLACEMENT 0\n');

//                content = content.replace("LIBSPECTRUM_CAPABILITIES", product.moduleProperty("configure", "LIBSPECTRUM_CAPABILITIES"));
//                var LIBSPECTRUM_SNAP_ACCESSORS='';
//                var snaps = new TextFile(baseDir + '/snap_accessors.txt');
//                while (!snaps.atEof()) {
//                    var line = snaps.readLine().trim();
//                    if (!line.length || line.charAt(0) == '#')
//                        continue;

//                    var data = line.split(" ");
//                    switch (data.length) {
//                    case 2:
//                        LIBSPECTRUM_SNAP_ACCESSORS += data[0] + ' libspectrum_snap_' + data[1] + '( libspectrum_snap *snap );\n';
//                        LIBSPECTRUM_SNAP_ACCESSORS += 'WIN32_DLL void libspectrum_snap_set_' + data[1] + '( libspectrum_snap *snap, ' + data[0] + ' ' + data[1]  +');\n';
//                        break;
//                    case 3:
//                        LIBSPECTRUM_SNAP_ACCESSORS += data[0] + ' libspectrum_snap_' + data[1] + '( libspectrum_snap *snap, int idx );\n';
//                        LIBSPECTRUM_SNAP_ACCESSORS += 'WIN32_DLL void libspectrum_snap_set_' + data[1] + '( libspectrum_snap *snap, int idx, ' + data[0] + ' ' + data[1]  +');\n';
//                        break;
//                    }
//                }
//                content = content.replace("LIBSPECTRUM_SNAP_ACCESSORS", LIBSPECTRUM_SNAP_ACCESSORS);

//                var LIBSPECTRUM_TAPE_ACCESSORS='';
//                var snaps = new TextFile(baseDir + '/tape_accessors.txt');
//                while (!snaps.atEof()) {
//                    var line = snaps.readLine();
//                    if (!line.length || line.charAt(0) == '#')
//                        continue;

//                    var data = line.split('\t');
//                    for (var i=0; i<data.length;) {
//                        if (data[i] == '')
//                            data.splice(i, 1);
//                        else
//                            i++;
//                    }

//                    if (data.length < 4)
//                        continue;

//                    if (data[2] == '1') {
//                        LIBSPECTRUM_TAPE_ACCESSORS += data[0] +' libspectrum_tape_block_' + data[1] + '( libspectrum_tape_block *block, size_t idx );\n';
//                        LIBSPECTRUM_TAPE_ACCESSORS += 'WIN32_DLL libspectrum_error libspectrum_tape_block_set_'+ data[1] +'( libspectrum_tape_block *block, ' + data[0] + '* ' + data[1] + ' );\n';
//                    } else {
//                        LIBSPECTRUM_TAPE_ACCESSORS += data[0] +' libspectrum_tape_block_' + data[1] + '( libspectrum_tape_block *block );\n';
//                        LIBSPECTRUM_TAPE_ACCESSORS += 'WIN32_DLL libspectrum_error libspectrum_tape_block_set_'+ data[1] +'( libspectrum_tape_block *block, ' + data[0] + ' ' + data[1] + ' );\n';
//                    }
//                }
//                content = content.replace("LIBSPECTRUM_TAPE_ACCESSORS", LIBSPECTRUM_TAPE_ACCESSORS);

//                file = new TextFile(output.filePath, TextFile.WriteOnly);
//                file.truncate();
//                file.write(content);
//                file.close();
//            }
//            return cmd;
//        }
//    }

    Rule {
        inputs: ["settings.dat", "settings-header.pl"]
        Artifact {
            fileTags: 'settings.h'
            filePath: 'settings.h'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'settings-header.pl', 'settings.dat'];
            cmd.workingDirectory = FileInfo.path(input.filePath);
            cmd.stdoutFilePath = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["z80.pl", "opcodes_base.dat"]
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'settings-header.pl', 'settings.dat'];
            cmd.workingDirectory = FileInfo.path(input.filePath);
            cmd.stdoutRedirectFile = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["z80.pl", "opcodes_base.dat"]
        Artifact {
            fileTags: 'opcodes_base.c'
            filePath: 'opcodes_base.c'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'z80/z80.pl', 'z80/opcodes_base.dat'];
            cmd.workingDirectory = product.sourceDirectory;
            cmd.stdoutFilePath = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["z80.pl", "opcodes_base.dat"]
        Artifact {
            fileTags: 'z80_cb.c'
            filePath: 'z80_cb.c'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'z80/z80.pl', 'z80/opcodes_cb.dat'];
            cmd.workingDirectory = product.sourceDirectory;
            cmd.stdoutFilePath = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["z80.pl", "opcodes_ddfd.dat"]
        Artifact {
            fileTags: 'z80_ddfd.c'
            filePath: 'z80_ddfd.c'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'z80/z80.pl', 'z80/opcodes_ddfd.dat'];
            cmd.workingDirectory = product.sourceDirectory;
            cmd.stdoutFilePath = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["z80.pl", "opcodes_ddfdcb.dat"]
        Artifact {
            fileTags: 'z80_ddfdcb.c'
            filePath: 'z80_ddfdcb.c'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'z80/z80.pl', 'z80/opcodes_ddfdcb.dat'];
            cmd.workingDirectory = product.sourceDirectory;
            cmd.stdoutFilePath = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["z80.pl", "opcodes_ed.dat"]
        Artifact {
            fileTags: 'z80_ed.c'
            filePath: 'z80_ed.c'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'z80/z80.pl', 'z80/opcodes_ed.dat'];
            cmd.workingDirectory = product.sourceDirectory;
            cmd.stdoutRedirectFile = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["z80.pl", "opcodes_ed.dat"]
        Artifact {
            fileTags: 'z80_ed.c'
            filePath: 'z80_ed.c'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'z80/z80.pl', 'z80/opcodes_ed.dat'];
            cmd.workingDirectory = product.sourceDirectory;
            cmd.stdoutFilePath = output.filePath;
            return cmd;
        }
    }

    Rule {
        inputs: ["settings.dat", "settings.pl"]
        explicitlyDependsOn: ['settings.h', 'opcodes_base.c', 'z80_cb.c', 'z80_ddfd.c', 'z80_ddfdcb.c', 'z80_ed.c']
        Artifact {
            fileTags: 'c'
            filePath: 'settings.c'
        }

        prepare: {
            var cmd = new Command();
            cmd.description = 'generating ' + output.fileName;
            cmd.highlight = 'codegen';
            cmd.program=product.moduleProperty("configure", "PERL_PATH");
            cmd.arguments= ['-I./perl', 'settings.pl', 'settings.dat'];
            cmd.workingDirectory = FileInfo.path(input.filePath);
            cmd.stdoutFilePath = output.filePath;
            return cmd;
        }
    }
}
